# clone 재정의는 주의해서 진행하라
자바에서 제공해주는 clone()과 cloneable 인터페이스에 대해서 알아보자 <br>
<br>

clone()은 Object에 정의되어 있는 메소드이고, cloneable 이라는 인터페이스는 텅 비어있는 인터페이스이다 <br>
cloneable은 우선 아무것도 구현되어있지 않은 비어있는 메소드인데, 약간 이걸 implement 함으로써, clone()을 사용할 것이다 <br>
라고 선언하는 것과 같은 그러한 개념이다 <br>
<br><br>

clone() 메소드는, 이름과 같이 지정한 객체와 같은 객체를 생성하는 것이다 특징으로는 같은 객체이지만, 레퍼런스는 다른 객체이다 <br>
이렇게 clone()을 구현하는데 있어서 들어가야하는 규약은 몇가지가 존재한다 <br>
<br>

우선, 원본.clone() != 원본 의 결과값은 항상 TRUE 여야만 한다 <br>
요건 위에서 잠깐 이야기한 것 처럼, 내부의 값들은 같을 수 있어도, 완전히 새로운 객체를 생성하는 것이기 때문에 주소가 다르고 객체가 다를 수 밖에 없다고 볼 수 있다 <br>
<br>

두번째로, 원본.clone().getClass() == 복사된놈.getClass() 은 항상 TRUE 이여만 한다 <br>
객체 자체는 같은 객체를 복사하는 개념이기 때문에 원본과 복사본의 객체 타입인 클래스는 항상 같아야만 한다 <br>
<br>

세번째로, 원본.clone.equals(복사본) 은 TRUE가 아닐수도 있다 <br>
이것의 이유는 객체의 성질마다 다르다고 볼 수 있다 -> 만약 객체의 특징으로 객체가 각각의 독립적인 ID가 있다면 복제하는 순간, 다른 아이디를 가진 객체가 생성되기 떄문에 항상 true라고 볼 수는 없다 <br>
<br>

구현은 cloneable implements한 후, clone() 메소드를 override 하면서 재정의해주면 된다 <br>
주의해야할 점으로는, overriding 시, 구현하는 하위메소드의 접근지시자는 상위메소드의 접근지시자와 같거나 더 넓은 범위로 선언되어야 한다 <br>
그리고 clone() 메소드의 리턴 타입도 상속받는 Object의 객체가 아닌, 해당 메소드를 override 한 자식클래스의 타입으로 타입캐스팅을 해주고 넘겨주는 것도 가능하다 <br>
그리고 구현하는 과정에 있어서 꼭 super.clone()을 통해서 상위 clone()을 호출해줘야 한다 -> 만약 생성자를 활용해서 직접 구현하게되면 맨 처음에서의 규약이 깨지게 된다 <br>
규약이 깨지는 부분은 원본.getClass().equals(복사본.getClass()) 에서 깨지게 된다. clone()을 직접 구현한 부모메소드를 상속받아 부모메소드의 커스텀 clone()을 사용하는 자식 메소드에서 에러가 나게 된다 <br>
이유는 간단하다 자식클래스에서 부모클래스의 clone()을 사용한다고 보면, (부모)자식 이렇게 타입캐스팅은 가능하지만 (자식)부모 이렇게 타입캐스팅은 불가능하기 때문이다 <br>
이렇게 확인해야할 것은 2가지이다 clone() 메소드를 사용하기 위해서는 cloneable을 implements 받고, 재정의하는 과정에서 super.clone()을 사용하라 <br>
<br>

근데 가변객체는 어떻게 처리하냐 <br>

