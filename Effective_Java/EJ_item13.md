# clone 재정의는 주의해서 진행하라
자바에서 제공해주는 clone()과 cloneable 인터페이스에 대해서 알아보자 <br>
<br>

clone()은 Object에 정의되어 있는 메소드이고, cloneable 이라는 인터페이스는 텅 비어있는 인터페이스이다 <br>
cloneable은 우선 아무것도 구현되어있지 않은 비어있는 메소드인데, 약간 이걸 implement 함으로써, clone()을 사용할 것이다 <br>
라고 선언하는 것과 같은 그러한 개념이다 <br>
<br><br>

clone() 메소드는, 이름과 같이 지정한 객체와 같은 객체를 생성하는 것이다 특징으로는 같은 객체이지만, 레퍼런스는 다른 객체이다 <br>
이렇게 clone()을 구현하는데 있어서 들어가야하는 규약은 몇가지가 존재한다 <br>
<br>

우선, 원본.clone() != 원본 의 결과값은 항상 TRUE 여야만 한다 <br>
요건 위에서 잠깐 이야기한 것 처럼, 내부의 값들은 같을 수 있어도, 완전히 새로운 객체를 생성하는 것이기 때문에 주소가 다르고 객체가 다를 수 밖에 없다고 볼 수 있다 <br>
<br>

두번째로, 원본.clone().getClass() == 복사된놈.getClass() 은 항상 TRUE 이여만 한다 <br>
객체 자체는 같은 객체를 복사하는 개념이기 때문에 원본과 복사본의 객체 타입인 클래스는 항상 같아야만 한다 <br>
<br>

세번째로, 원본.clone.equals(복사본) 은 TRUE가 아닐수도 있다 <br>
이것의 이유는 객체의 성질마다 다르다고 볼 수 있다 -> 만약 객체의 특징으로 객체가 각각의 독립적인 ID가 있다면 복제하는 순간, 다른 아이디를 가진 객체가 생성되기 떄문에 항상 true라고 볼 수는 없다 <br>
<br>

구현은 cloneable implements한 후, clone() 메소드를 override 하면서 재정의해주면 된다 <br>
주의해야할 점으로는, overriding 시, 구현하는 하위메소드의 접근지시자는 상위메소드의 접근지시자와 같거나 더 넓은 범위로 선언되어야 한다 <br>
그리고 clone() 메소드의 리턴 타입도 상속받는 Object의 객체가 아닌, 해당 메소드를 override 한 자식클래스의 타입으로 타입캐스팅을 해주고 넘겨주는 것도 가능하다 <br>
그리고 구현하는 과정에 있어서 꼭 super.clone()을 통해서 상위 clone()을 호출해줘야 한다 -> 만약 생성자를 활용해서 직접 구현하게되면 맨 처음에서의 규약이 깨지게 된다 <br>
규약이 깨지는 부분은 원본.getClass().equals(복사본.getClass()) 에서 깨지게 된다. clone()을 직접 구현한 부모메소드를 상속받아 부모메소드의 커스텀 clone()을 사용하는 자식 메소드에서 에러가 나게 된다 <br>
이유는 간단하다 자식클래스에서 부모클래스의 clone()을 사용한다고 보면, (부모)자식 이렇게 타입캐스팅은 가능하지만 (자식)부모 이렇게 타입캐스팅은 불가능하기 때문이다 <br>
이렇게 확인해야할 것은 2가지이다 clone() 메소드를 사용하기 위해서는 cloneable을 implements 받고, 재정의하는 과정에서 super.clone()을 사용하라 <br>
<br>

근데 가변객체는 어떻게 처리하냐 <br>
가변객체도 구현 방식은 같다 그냥 단순하게 cloneable을 implemnet하고 public으로 clone()을 overriding하면 된다 <br>
근데 다음으로 문제는 만약에 단순하게 이렇게만 구현하고 클론을 했다고 가정했을 때 문제는 원본과 복제본 모두가 같은 배열을 바라보는 이슈가 생긴다 <br>
이런 현상은 기본적으로 구현한 클론에서는 얕은 복사, shallow copy가 되기 때문이다. 복사하는데 해당 내부의 엘리먼트도 같이 새로이 복사되는 것이 아니라 내부의 인스턴스를 같은 인스턴스를 바라보는 이슈이다 <br>
물론 문제로써는, 복제본과 원본은 클론 이후에 완벽하게 독립된 객체여야 하는데, 둘 중에 하나만 변경되더라도 다른 객체에 영향이 가는 그러한 문제이다 <br>
그래서 방법으로는 얕은 복사가 아니라, deep copy를 해줘야 한다는 것이다 <br>
<br>

그러면 클론을 재정의하는 과정에서 필드도 클론을 따로 해주는 것이 방법이냐 -> 그것도 아니다 여전하게 얕은 복제라고 볼 수 있다 <br>
그럼 deep copy를 하는 것은 어떻게 하냐 <br>
그냥 새로운 배열을 new를 통해서 생성하고 하나하나 집어넣어주는 것이 하나의 방법이다 <br>
그리고 너무 재귀적으로 생성하지 않도록 주의하자 많이 재귀적으로 구현을 해버리면 stackoverflow 에러에게 노출될 수 있기 때문이다 <br>
그래서 deep copy를 구현할 때 어떻게 구현하는게 좋냐 <br>
어떻게 구현하기 좋은 방법 중 하나는 <br>
클론 내부에서 복잡한 메소드인 put이나 get 같은 클론이 무거워짐으로써 좋지 않은 퍼포먼스를 내는 이슈가 생긴다 <br>
그리고 클론 내부에 재정의할 수 있는 메소드는 넣지 말아야 한다 -> 만약 재정의할 수 있는 메소드가 들어가게 되면 재정의하면서 내부의 동작이 변경될 예정이기 때문이다 <br>
상속을 이용하는 경우에는 상위클래스에서 먼저 clone을 구현해두고 하위 클래스에다가는 clone을 재정의할 필요 없이 그냥 부모클래스의 clone을 사용하고 타입캐스팅을 통해서 클론을 사용하게 해줄 수 있다 <br>
마지막으로 클론이라는 메소드가 스레드로부터 안전하게 사용되어야 한다면, 클론을 재정의할때, synchronized 키워드를 붙혀서 도와주자 <br>
<br><br>

근데 막상 이렇게 주저리주저리 적었지만 결국은 clone이라는건 안쓰게 되고 결국은 생성자를 사용해서 객체를 새로 복사하든 작업을 진행하는데, <br>
예시로 준 것은 Set 자료구조를 TreeSet의 생성자를 사용하면 TreeSet의 내부에 존재하는 클론을 통해서 객체를 복사할 수 있다 <br>
다른 객체에는 그런거 말고도 따로 클론을 해주는 클론 팩토리 메소드를 생성하는 것도 방법 중 하나이다 <br>
<br><br>

근데 클론같은걸 사용하기 위해서는 객체의 내부에 존재하는 final 같은 것들도 사용할 수 없다.. 그렇기 때문에 그렇게 막 좋다~ 이렇게 이야기하기는 조금 애매하고 사용하기도 애매하다고 생각된다 <br>
그래서 그냥 clone은 지양하고 생성자를 사용해서 객체의 복제를 진행하거나 따로 구현한 클론 팩토리 메소드를 사용하자 <br>

