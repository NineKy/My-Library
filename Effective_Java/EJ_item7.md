# 다 쓴 객체 참조를 해제하라

<br><br>

객체의 참조를 해제한다는 의미는 사용이 끝난 객체에 null 을 할당해 준다는 의미이다 <br>
GC 는 객체를 수거할 때 Mark, Sweep, Compact 이 3가지를 진행한다고 했는데, 이 중에서 다 쓴 객체라고 판단하고 mark를 진행하는
객체가 바로 해당 객체에 대한 참조가 더 이상 존재하지 않을 때이다 <br>
<br>

그래서 책에서 들어주는 예시로는 우선 스택이 있다 <br>
스택이라는 자료구조를 보면 배열이 존재하고, 해당 배열에서 하나씩 pop 한다고 생각했을 때 pop 한다고 해서 <br>
배열 내에 pop 된 객체가 어딘가로 사라지는 것이 아니라 계속해서 남아 있게 된다 <br>
그래서 위와 같은 케이스에서 객체 참조를 제외하기 위해서 사용하는 방법 중 하나는 pop 된 객체의 위치에 null 을 집어 넣어주는 것이다 <br>
<br>

물론 실제 현재 stack이 이렇게 되어있다는 건 아닌데, 이렇게 굳이 메모리를 신경쓰지 않고 개발을 진행했더라도 <br>
객체에 대한 주의를 가지고 개발을 진행해야 한다는 것이 포인트이다 <br>
<br><br>

두 번째로의 예시는 캐시를 언급한다 <br>
캐시 같은 경우는 위에서 처럼 Null 을 넣어주는 것이 없다 그럼 위에 처럼 계속해서 메모리에 객체는 쌓여만 갈 것인데 
이런 케이스에서는 어떻게 처리해야하나 -> 여기서 말해주는건 WeekHashMap 이다 <br>
WeekHashMap 은 WeekReference 를 키로 가지는 HashMap 을 의미하고 이후에 다시 볼 예정 <br>
이것의 특징은 키가 더 이상 참조가 되지 않으면 키와 같이 키에 대한 value 도 GC가 진행될 때 같이 날라가는 그러한 특징을 가지고 있다 <br>

<br><br>

세 번째로는 직접 객체의 참조를 넣어거나 참조를 해제하는 과정을 직접 관리하는 방법이다 <br>
그 방식으로는 LRU(Least Recently Used) Cache 방법이 있다 <br>
LRU 는 페이지를 교체하는 데 있어서 가장 오랫동안 사용되지 않은 것을 교체 대상으로 삼는 그러한 알고리즘이다 <br>
LRU Cache 는 캐시에 공간이 부족할 때 가장 오랫 동안 사용하지 않은 놈을 제거하고 새로운 놈을 넣어주는 그러한 방식이다 <br>
상식적으로 가장 오랫 동안 사용되지 않았다는 의미는 앞으로도 사용될 가능성이 가장 낮은 놈이다 라고 판단하기 때문이다 <br>
실제로 이러한 알고리즘이 성능적인 면에서 보증 받기도 했고, 캐시 히트율을 높게 유지할 수 있었다고 한다 <br>
<br>

그래서 물론 LRU 와 같은 알고리즘이 있으면 사용하면 되겠지만 객체를 관리하는데 있어서 필요하다면, 직접 LRU 를 구현해서 관리하는 그러한 방식을 의미하는 것이다 <br>
<br><br>

4 번째로는 백그라운드 스레드를 사용해서 주기적으로 cleanup 을 실행하는 것을 구현하는 것이다 <br>
scheduled thread pool executor 가 의미하는 것이다 <br>
개념 자체는 배치와 같다고 생각하면 된다 따로 콜백이나 메소드를 호출함으로써 동작되도록 하는 것이 아니라 <br>
ScheduledExcutorService.scheduleAtFixedRate() 을 통해서 원하는 시간 마다 백그라운들 스레드를 통해서 동작하게 해주는 것이다 <br>
이외에도 리스너를 통해서 구현하는 것도 가능하다 <br>
리스너는 어떠한 이벤트에 대해서 발생하는 리스너로 map 과 같은 곳에 담아두었다가 이벤트가 발생했을 때 동작하게 해주는데, <br>
이 리스너에 대한 cleanup 을 고려하지 않는다면, 이벤트가 메소드 범위를 넘어서지 않고 호출이 종료된다면, 그래도 메모리에 남아있는 그러한 문제가 생긴다 <br>
그래서 이건 또 Week Reference 을 통하면 그나마 쉽게 처리하는 것이 가능하다 <br>
<br><br><br>


