# item3 - 생성자나 열거타입으로 싱글턴임을 보증하라

\
\


무조건적으로 싱글턴으로 만들어서 사용하라는 의미는 아니고, 꼭 하나만 존재해야하는 것이나 하나의 인스턴스만 가지고 시스템이 돌아가는 그러한 케이스들이 존재한다\
예시로 보면 게임의 설정을 진행하는데 있어서 한국어로 진행할 것인지, 영어로 진행할 것인지 정할때 정하고나서 설정된 언어가 바뀌면 게임할 때 영어와 한국어가 뒤죽박죽일 것이다\
이런 케이스에 사용하면 된다고 보면 된다\
그렇기 때문에 무조건적으로 이렇게 하는게 좋다! 가 아니라 필요할 때 사용하면 된다\


생성자를 사용하는 방법 - private 생성자 + public static final 필드\



장점으로는 알아보기 쉬우며 간결하다. 그리고, 싱글톤의 장점을 활용해서 사용하는 것이 가능하다고 한다\
하지만 실제로 그렇게 쓰는건 본인 기준으로는 보기 쉽지는 않았다.. 그 이유는 역시 그럼 단점이 많은 것이겠지?\


단점으로는 **클라이언트의 클래스를 테스트하기 어려워진다** 라고 되어있는데,\
우선 클라이언트 코드란, 싱글톤으로 생성한 클래스와 해당 인스턴스를 사용하는 코드라고 볼 수 있다\
클라이언트에서 테스트를 진행하는데 있어서, 클라이언트를 테스트 진행할 때 싱글톤으로 생성한 놈을 부르는 순간,\
단 하나의 인스턴스로 구성되어있기 때문에 그 인스턴스를 가져와서 테스트를 진행하게 된다\
\


강의에서 말씀하신 콘서트장에서 콘서트 준비를 하면서 항상 엘비스를 불러다가 여러가지 조명이나 장막 등등을 테스트할 수는 없는 것이랑 같다\
\


우선적으로 이러한 문제를 해결하는 방법으로는 **해당 클래스의 인터페이스를 구현** 이 방법이다\
해당 클래스로부터 인터페이스를 만들고, 싱글톤 클래스를 해당 인터페이스를 implement하게 만들어두고, 또 새로운 테스트용 클래스를 생성하는 것이 방법이다\
예시로 보면 엘비스를 포함하는 I엘비스라는 인터페이스를 생성하고, Mock엘비스라고 만들어둔 다음, Mock엘비스를 가지고 테스트를 진행할 수 있는 것이다\
\
\


또 다른 단점으로는 **리플렉션으로 private 생성자를 호출할 수 있다**는 것이다\
그리고 위의 의미는 결국 싱글톤이 깨진다는 의미를 가지고 있는 것이다 -> 그럼 결국 싱글톤의 의미가 사라지는 그러한 모순이 생기는 것이다\
\


하는 방법으로는\
class.getDeclaredConstructor()를 통해서 생성자를 들고오고, setAccessable을 통해서 자바코드에서 접근 가능하도록 설정 후, 생성하면 생성할 수 있다\
이러한 버그?성을 막기 위해서는 원본클래스에서 생성자가 한 번 이상 불리는 것을 막아주는 방어코드를 집어넣어주라고 하고 있다\
\


이 외에도 문제가 있는게, 직렬화 <> 역직렬화 하는 과정에서 기존 객체가 나오는 것이 아닌 새로운 객체가 계속해서 생성된다는 문제가 존재한다\
위 문제는 또 readResolve이라는 함수를 통해서 역직렬화를 통해서 보장해주는 것이 가능하다고 한다\
\


이렇게 계속해서 단점이 쌓여가는 상황이다\


## 생성자를 사용하는 방법 - private 생성자 + 정적 팩토리 메소드

첫 번째의 경우와는 다르게, 직접 public한 인스턴스를 가져와서 사용하는 것이 아닌, private 한 인스턴스를 생성해두고, getInstance와 같이 인스턴스를 꺼내주는 함수를 public으로 만들어서 사용하도록 하는 방법이다\
일단 이 방법에 대해서는 어떻게 보면 그냥 눈가리고 아웅 하는 느낌이다 그래서 단점도 첫 번째와 같이 가지고 있는 상황이다\
하지만 그래도 장점이 더 있다고하니 봐보자\


첫 번째 장점으로는 클라이언트가 더욱 간결해진다는 점이다 그 의미는 어떠한 로직이 추가될지 모르는 등 다양한 경우에 만약 실제 그냥 인스턴스를 가져왔다면\
코드가 더 길어지면서 알아보기 힘들게 된다는 점이다 하지만 인스턴스를 꺼내주는 함수를 사용함으로써 **클라이언트의 코드는 그대로 두되, 인스턴스에 대한 조작이 가능**하다\
\


두 번쨰 장점으로는 제네릭 싱글톤 팩토리를 사용할 수 있다 인데,\
우선 이것은 제네릭 타입을 통해서 인스턴스를 내뱉고 싶을 때, 원하는 타입을 통해서 인스턴스를 생성하는 것이 가능하다는 것이다\
그 의미는, **같은 인스턴스를 원하는 타입으로 형변환을 해서 사용할 수 있다는** 장점을 가진다는 의미이다\
제네릭 싱글톤 팩토리에 엄청난 것이 들어가는 것도 아니고 단지 형변환만 해주는 코드만 들어가는 상황이다\
\


마지막 장점은 정적 팩토리의 메소드 참조를 supplier로 사용할 수 있다는 것인데\


supplier을 통해서 메소드 레퍼런스로 static 팩토리 메소드를 사용하는 것이 가능하다\


```java
Supplier<클래스> instance = 클래스::getInstance
//이렇게 아니면
Supplier<클래스> instance = () → 클래스.getInstance()
```

\
\
\


## 책에 나온 키워드

\
\


#### 메소드 레퍼런스

간단하게 보면 메소드 하나만 호출하는 람다 표현식을 간단하게 쓰는 방식이다\
일단 조건 자체는 간단하다 그냥 함수에서 단 하나의 작업, 즉 단 하나의 함수를 호출하고 싶을 때 사용하는 것이 가능하다\
기존의 사용은 함수 내에서 아무런문자(어떠한객체에대해서) -> {여기서 어떠한 객체에 대한 작업들을 작성하는 것이 가능했다} <\
위의 케이스는 단순하게 하나의 로직이 아닌 다양한 함수를 호출하거나 할 때 필요한 부분이고\
만약 해당 객체에 대해서 단 하나의 함수를 작업하려고 하면 그냥 클래스::함수 이렇게만 작성해주면 된다\
자주 쓰는데 아주 편리하고 비쥬얼적으로도 아주 보기 좋다는 걸 잘 알고 있다\
\


조금 더 보자면, 메소드 레퍼런스에는 크게 4가지 종류가 있다\


* static 메소드 레퍼런스
* 인스턴스 메소드 레퍼런스
* 임의 객체의 인스턴스 메소드 레퍼런스
* 생성자 레퍼런스

\
기본적인 사용방법이 static 메소드 레퍼런스이다\
클래스 내부에 static으로 선언된 함수를 ::을 통해서 사용하는 것이 가능하다\
static하지 않은, 인스턴스 메소드는 바로 메소드 레퍼런스를 사용할 수는 없고, 인스턴스 메소드 레퍼런스를 사용하기 위해서는 객체를 하나 생성하고 나서\
클래스::메소드가 아닌 생성한 객체::메소드 <- 이러한 방식으로 사용해야 한다\
그리고 강의에서는 compare라는 함수를 예시로 들어주고 있었는데 내용은 이러하다, 두 가지의 인자를 받아서 비교하고 int을 넘겨주는 그러한 상황인데,\
만약 compare의 구현체가 넣어주는 인자 클래스 내부에 구현이 되어있다면 하나의 인자를 받고, 나머지 하나는 this을 통해 자기자신을 비교하는 것이 가능하다\
마지막으로 생성자 레퍼런스는 new 객체() 이러한 방식이 아닌 클래스::new 이러한 방식으로 생성하고자 하는 것이다\
기본적으로 input에 맞는 생성자를 맞춰서 사용되게 되어 있다. 이것은 클래스::new를 추출해보면 알지만, Function<특정한인자, 만들고자하는 객체클래스> 이렇게 functional 객체로 해서 튀어나온다\


근데 만약에 생성자가 인자별로 다양하게 존재해서 어떤 인자를 가진 생성자를 참조할지 모르는 경우에는 어떻게 할까 이건 함수형 인터페이스를 따로 넣어줘서 사용할 수 있다\
\


#### 함수형 인터페이스

우선 함수형 인터페이스는 람다 표현식과 메소드 참조에 대한 타겟타입을 제공하는 인터페이스이다\
원하는대로 만드는 것도 가능한데, interface에 단 하나의 메소드만을 가지고 있다면 만드는 것이 가능하다, @FunctionalInterface을 통해서 선언해주고 함수가 단 하나만 있다면 원하는대로 생성도 가능 필요하면 사용할 수 있다\
\
\


함수형 인터페이스들은 이렇게나 많다..\
[https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)\
\
\


Function<인풋타입, 아웃풋타입> 에 대해서\
간단하게 인풋을 넣어주면 해당 인풋에 대한 아웃풋을 리턴해주는 그러한 함수라고 생각하면 된다

```java
Function<Integer, String> parseString = (i) -> "this is String";
Function<Integer, String> parseString = Object::toString;
```

Supplier에 대해서….\
Supplier에는 get()이라는 함수만을 가지고 있는 추상 인터페이스이다.\
이것의 특징은 매개변수를 받지 않고 단순하게 무언가를 리턴해주는 추상 메소드가 존재한다는 점이다\
즉 받는건 없어도 뭔가를 뱉는 그러한 메소드라는 의미이다\
제네릭 타입으로 선언되어있기 때문에 원하는걸 리턴해주는 것이 가능하지만, 특별하게 원하는 primitive 타입을 던질 수 있는 BooleanSupplier, DoubleSupplier, intSupplier, LongSupplier 도 존재하니 필요하면 사용할 수 있다\
\


Consumer\
매개변수를 받고, 리턴해주는 것이 없는 함수이다\
예시로는 System.out.println이 있다 -> 입력하고 싶은 인자를 받아서 콘솔에 출력하고 막상 리턴하는 것은 없다\
\


Predicate\
매개변수를 받고 해당 매개변수에 대한 조건을 거치고 조건에 대한 true/false를 리턴하는 함수\
\
예시로는 stream.filter 가 존재\
\
\
\


#### 객체 직렬화

직렬라는 것은 객체를 바이트스트림으로 상호 변환하는 기술이다\
예를 들면 자바 메모리에서 사용하던 객체나 값들을 어디 다른 시스템에서 사용하고 싶거나 네트워크를 통해 값들을 전달하고 싶을 때 사용된다\
마치 집에서 사용하던 물건들을 포장해서 이사하는 그러한 개념이라고 볼 수 있다\
그렇게 포장되면서 객체들은 바이트 스트림으로 변환되며, 바이트스트림이 파일로 저장되거나 네트워크를 통해서 전송되는 것이다\
그리고 포장된 객체들을 다시 풀어서 객체화 하는 것을 보고 역직렬화라고 한다\
\
사용 방법으로는\
직렬화를 하기 위해서는 Serializable 이라는 인터페이스를 implements하는 것으로 사용될 수 있다\
만약 모든 것을 직렬화하는 것이 아닌 몇개는 빼고 싶다 -> 접근지시자와 타입 사이에 transient 이라는 키워드를 사용해서 default값으로만 들어가게 수정 가능\
\


주의해야할 사항으로는\
객체를 직렬화 시켜놓고 해당 객체에 수정사항이 생겨 필드에 수정이 되었다면 -> 역직렬화에서 에러가 발생하게 된다\
여기서 에러가 나는 이유는 serialVersionUID의 차이에서 생기게 된다\
기존에 객체에 따로 선언은 하지 않았는데 -> 이건 애초에 jvm 이 런타임시에 임의대로 만들어준다\
이 직렬화, 역직렬화는 serialVersionUID를 통해서 진행되는데, 객체의 변경사항이 생기게 되면 serialVersionUID 가 변경되기 때문에 안되는 것이다\
그래서 이건 따로 일부러 객체내부에 private static final Long serialVersionUID = 원하는 숫자 이렇게 따로 구현을 해두어야 객체에 변경사항이 있어도 직렬화, 역직렬화가 가능하다\
\
\
\


\
\
\
\
\
\
\
\
\
\
