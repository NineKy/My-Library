# 다이나믹 프록시

## 프록시란?

본인이 알고 있는 프록시란 IP 주소를 우회하는 IP 우회용 프록시 애플리케이션을 통하게되면\
본인이 사용하고 있는 IP 주소가 아닌 다른 IP로 설정해서 웹에 접속하는 방식이다\
즉, 웹페이지에서는 내가 진짜 내가 사용하는 IP 주소가 아닌, 프록시를 통해서 받거나 설정한 IP로 접속하는 것으로 보이는 것이다\
\
\


이러한 개념인데 프록시 패턴이라고 하면 위의 개념과 비슷하다\
프록시 패턴은 실제로 접근하려는 코드를 **직접적으로 접근하지 않고** 프록시 코드를 통해서 수정하거나 새로운 부가기능을 추가하는 방식이다\
\
\


구현된 방식은 이러하다\
설명하기 전, 우선 실제 접근하려고 하는 부분을 실객체라고 하겠다\
프록시와 실객체와 서로 공유하는 인터페이스가 존재하고 해당 인터페이스 타입으로 프록시를 사용자가 사용하는 방식이다\
물론 가운데에서 인터페이스가 존재하고 있기 때문에 -> 사용자는 직접 실객체에 대한 접근이 불가능하기 때문에 기존 객체의 함수를 수정하거나 부가기능을 추가하는 것들이 불가능하다\
그래서 실객체에는 진짜 기본적인 기능만 들어가 있는 상태에, 그 실객체를 프록시로 빼서 부가적인 기능을 붙힐 때 이러한 패턴이 사용되기 좋다\
\


만약에 사용하게 되면 단점은 실객체가 많아지는 순간, 그 많은 실객체의 수 만큼 프록시클래스를 하나하나 만들어줘야 하고, 반복되는 코드들을 다시 똑같이 구현해야하는 단점이 존재\
\
\


## 다이나믹 프록시란?

다이나믹 프록시라는 것은, 위에서 프록시의 단점이였던 실객체가 많아지면 많아질수록, 일일이 만들어줘야하는 그런 고생을 없애기 위한 방식이다\
실제 프록시 코드를 컴파일 시점에 만드는 방식이 아닌, 런타임 시점에 클래스 또는 인스턴스를 만드는 기술이다\
\
\


생성하는 방법은 Proxy.newProxyInstance()이라는 함수를 사용해서 생성한다\
첫 번째 인자로는 프록시로 만들고 싶은 클래스로더를,\
그리고 두 번째 인자로는 해당 프록시가 어떤 인터페이스 타입의 프록시이냐를 표시하는 값을 넣어준다\
그리고 마지막 인자로는 InvocationHandler 라고 해당 프록시가 호출되었을 때 어떠한 일을 할 것인지에 대한 설명 하고 실객체는 여기 내부에서 가지고 있어야한다\
이렇게 newProxyInstance()를 이용하면 Object 객체를 생성하기 때문에 타입캐스팅을 사용해주어야함\
하지만 유의해야하는 점은 **클래스**를 가지고는 만들 수 없다는 점이다 -> **자바를 기준으로는 항상 인터페이스**만 만들 수 있다는 점을 기억하자

```java
MyService service = Proxy.newProxyInstance(MyService.class.getClassLoader(), new Class[]{MyService.class}, 
    new InvocationHandler(){
        MyService myService = new MyService();
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
            return null;
        }
    });
```

\


사용자체는 이렇게 하지만 사실 invocationHandler는 생각보다 그렇게 유연하지 않다\
단순하게 한 두개의 기능을 넣는다고하면 위에 코드를 만든 거 처럼 하면 되지만 계속 작성해야하면 끝도없이 늘어난다\
그.래.서 스프링에서는 이러한 단점을 뜯어고쳐서 만들어둔게 있고, 그것을 보고 스프링 AOP라고 한다\
스프링 AOP에는 프록시패턴을 인터페이스단위로 만들어두었다. 그래서 스프링 AOP를 프록시기반의 AOP라고 부르는 것이다\
\
\
\


위에서 나왔던 클래스가 인터페이스를 가지고 있지 않는경우에는 프록시를 사용하지 못하냐? 그건 아니다\
크게는 2가지의 라이브러리를 사용해서 만드는 것이 가능함 -> CGlib, ByteBuddy CGlib같은 경우에는 Enhancer.create(클래스.class, handler)로 해서 만들고 해당 handler는 MethodInterceptor를 통해서 위에서 만들었던\
InvocationHandler를 통해서 생성하는 것이 가능하다\
\
ByteBuddy는 new ByteBuddy().subClass(클래스.class).make().load(클래스.class.getClassLoader()).getLoaded()을 사용하게 되면 프록시 클래스가 튀어나오게 된다\
그리고 리플렉션 코드에서 했던 방식으로 튀어나온 프록시 클래스에 대한 인스턴스를 생성해준다\
이렇게 만들고 어떻게 원하는 작업을 넣을 것이냐\
위의 생성하는 메서드체이닝 내부의 make() 메소드 전에 method()이라는 메소드를 넣어줘서 어떤 메소드에서 어떤 작업을 수정할 것이다를 표현\
그리고 그 뒤에서는 intercept()이라는 메소드를 통해서 어떠한 작업을 할것인지등등을 넣어준다 그리고 InvocationHandler 같은 경우도 여기에서 구현한다\
\
\


생성해서 사용하는 것은 대충 이런방식으로 사용하게 되는데, 필요하면 찾아서 쓰면 된다\
하지만 문제는 모든 클래스에서 사용할 수 있는 것은 아니다\
이렇게 서브 클래스를 만드는 방법의 단점은 우선 상속을 사용하지 못하는 경우에는 프록시를 만들 수 없다는 점이다\
CGlib, ByteBuddy 두 가지 방법 모두 상속을 통해서 구현하는 방식이기 떄문에 private이 붙어있는 케이스이던가, final이 붙어있는 케이스는 사용할 수 없다는 단점이 있다\
**애초에 상속을 하게되면 하위클래스에서는 항상 부모 생성자를 호출하기 때문에 private이나 final이 붙어있으면 서브클래스를 생성할 수 없다**\
그렇다고 항상 클래스를 생성하면서 public하게 생성할 수는 없기 때문에 왠만하면 프록시를 사용하기 위해서는 인터페이스를 사용하자..\
그리고 애초에 프록시를 생성하는 케이스는 복잡하게 구현되있기 때문에 왠만하면 인터페이스를 가지고 있을 예정이기 때문에 잘 구현하자\
\
\


## 정리

다이나믹 프록시의 기법은 런타임에 인터페이스 또는 클래스의 프록시 인스턴스 또는 클래스를 만들어서 사용하는 프로그래밍 기법이다\
\


사용처는 다양하게 구현되어 있는데,\
우리가 아는 것들은 크게 스프링 JPA, 그리고 Mockito, 스프링 AOP, 그리고 하이버네이트의 lazy initialization 등에서 크게 다이나믹 프록시를 사용해서 구현이 되어있다\
원리를 이해하고 있으면 해당 라이브러리들을 파악하는데 이해하기 쉬울 것이라고 생각한다\
\
\
\


\
\
\
\
\
\
\
\
\
\
