# 리플렉션

## Java Reflection?

리플렉션은 투영이라는 의미를 가진 단어이고 유추하기 힘들수도 있지만 이 API들의 의미는\
클래스의 정보를 사용자에게 뱉어주는 그러한 기능을 가진 함수들이다\
\


사실 클래스를 만드는데 있어서 클래스를 만드는데 이걸 모를 일은 그렇게 많을 것 같지는 않다\
하지만 무언가를 만들다보면 클래스에 대한 정보를 요하는 경우가 있다\
\


실제로 과거에 클래스 자체에 대한 정보는 아니더라도 해당 클래스에 선언되어 있는 필드들을 찾을 일이 있었다\
그때는 이러한 기능? API? 가 있는줄도 모르고 정말 무식하게 접근했던 것 같다\
그때는 진짜 클래스적고 점찍고 뭔 함수가 있나... 이건뭐지... 쓰고 실행해서 결과확인하고 이러한 과정을 통하다보니\
클래스.getDeclaredFields() 이런거에서 값이 나오는 것을 보고 찾아서 사용하곤 했었다\
아무튼 이렇게 결국은 언젠가 사용할 떄가 올 수 도 있다는 점을 기억해서 이렇게 조금이라도 남겨두려고 한다\
\


## 클래스의 정보 조회

\


클래스를 정보를 가져오기 위해서는 해당 클래스의 인스턴스를 먼저 가져오고 객체로 만들어줘야 한다\
클래스 객체에 생성, 접근하는 방법은 일단 크게 2가지가 있다

```java
//1
Class<클래스> exClass1 = 클래스.class;

//2
클래스 exClass = new 클래스(); 
Class<? extends 클래스> exClass2 = exClass.getClass();
```

요런식으로 객체로 생성하는 것이 가능하다\
첫 번째 방식은 바로 그냥 클래스의 인스턴스를 통해서 가져오는 방식이고,\
두 번째 방식은 해당 클래스 객체를 만들어둔 상태에서 그 객체를 통해서 클래스에 접근하는 방식이다\
\


이외에도 클래스를 클래스의 경로와 이름까지 알고 있다면 경로를 통해서 가져오는 것도 가능하다\


```java
Class<?> exClass3 = Class.forName("경로.경로.경로.클래스");
```

이렇게도 가져올 수 있는데 src/main/java 부터니까 그건 주의하고 사용하자\


\
\


이렇게 클래스에 접근하는 방법을 알았으니 접근해서 사용할 수 있는 것들을 보자\
\


일단 클래스를 가져왔으면 클래스 내부에 선언되어 있는 필드들에 접근할 수 있다\


```java
Fields[] fieldArr = exClass2.getFields();
Fields[] fieldArrAll = exClass2.getDeclaredFields();
```

하지만 .getFields()로 가져온 배열을 막상 보면, public으로 선언되어 있는 필드만 나오게 된다\
근데 사실 적어도 클래스에 선언된 모든 필드가 나와야 뭘 구별하고 하지 않겠니\
그럴때 사용하는게 .getDeclaredFields()이다\
요걸 사용하게 되면 해당 클래스에 선언된 모든 필드가 촤라락 뽑혀나온다\
하지만 .getDeclaredFields()을 통해서 뽑은 필드에서 private이나 protected에 막상 접근하려고하면 막 접근 Exception이 떨궈질 수 있다\
그럴때는 해당필드.setAccessible(true) 요 함수를 통해서 뽑은 Field객체에 접근할 수 있게 해주면 좋다\
\
\


필드 이외에도, getMethods(), getConstructors(), getSuperClass(), getInterfaces() 등을 통해서\
해당 클래스 내부에 있는 모든 메소드, 생성자, 부모클래스, 인터페이스 등에 접근하는 것이 가능하다\


그리고 이렇게 클래스와 관련된 값들을 가져오는 함수들에 모두 빈값을 주게되면 모든 필드를 가져오게 되지만\
특정 이름을 적어주면 해당 이름을 가진 특정 값를 가져오게 된다\
\
\


이렇게 가져온 값들에 대한 특징들도 확인하는 것이 가능하다\
값을 위의 다양한 메소드들을 통해서 가져왔을 때 .getModifiers()을 통해서 int 타입으로 Modifier를 받을 수 있다\
그리고 int타입으로 받은 modifier에 대한 값을 확인하는 방법은 Modifier.isPrivate(받은 int값) 이나 Modifier.isStatic(받은 int값) 등을 통해서 진행하능\
다양하게 있으니까 원하는 건 찾아서 적용하자\


## 애노테이션과 리플렉션

애노테이션을 우리가 알고 자주 사용하는 @이름 이러한 형태를 가지고 있다\
또한 이것은 제공해주는 것을 사용하는 것 뿐만 아니라 따로 '생성'하고, 기능을 커스텀하며 '사용'하는 것이 가능하다\
\


근데 여기서 신기한 점은 위에서 사용했었던 리플렉션과 같은 클래스에도 .getAnnotations()가 있는데\
이놈을 단순하게 생성만 해둔 애노테이션을 가져오기 위해서 사용해보며 실제로 나오지는 않는다 왜?\
\-> 우선, 애노테이션은 근본적으로는 주석과 같은 것을 간주, 수행하지만 단순한 주석 기능보다는 원하는 커스텀 기능을 넣을 수 있다는 점이 특별한 점이다\
\-> 그래서 왜 단순히 애노테이션을 만들고 붙혀도 왜 안나오냐?\
getAnnotation()은 런타임시에 호출되며, 단순히 선언만한 애노테이션에 언제 사용될 것인지에 대한 추가가 있어야 사용할 수 있다\


```java
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.TYPE, ElementType.FIELD})
public @interface TestAnnotation {
    String test1() default "TEST";
    String test2();
}
```

이렇게 사용하는데, @Retention은 애노테이션의 생명주기를 관리해주는 애노테이션이다. 즉, 언제 사용할 수 있게 할 것인지 정하는 그런 애노테이션이다\
여기서 사용한 CLASS라는 정책은, 애노테이션을 단순하게 바이트코드에서 확인할 수 있는 수준으로만 정의해두고 런타임에서는 버려지는 메모리할당 정책이다\
만약에 실제로 애노테이션을 만들어서 DI를 수행하고 싶다면 왠만하면 RUNTIME 정책을 채택해서 사용하는 것이 편하다\
그리고 @Target 애노테이션은 해당 애노테이션이 어떠한 위치에서 사용될 수 있는지를 정해주는 애노테이션이다\
위 예시 같은 경우에는 field에다가 추가했기 떄문에 그 의미는 오직 필드에서만 사용할 수 있게 해주는 그러한 능력이다\
\
\


애노테이션 내부에는 값들을 넣어줄 수 있는데, 여기에는 primitive 타입과, boxing된 reference 타입 그리고 리스트등 다양한 타입을 가진 것들이 들어갈 수 있다\
하지만 특별한 점은 필드를 선언하는데 있어서 우리가 기존에 선언하는 것과는 달리 ()을 붙혀서 함수를 만드는 것 처럼 비슷하게 만들어햐 한다\
그리고 위에서 본 것 처럼 ()뒤에 default 을 넣어줘야 한다\
default를 넣어주지 않는다면, 애노테이션을 선언해줄 때 @TestAnnotation(test2 = "qwer") 이렇게 선언해주지 않은 값들에 대해서 넣어줘야 한다\
만약에 애노테이션 내부에 필드를 선언할 때 있어서 value()라는 이름을 가진 함수가 있다면 따로 애노테이션 선언 시, 이름을 지정해서 정해줄 필요는 없다\
\


이러한 식으로 애노테이션을 선언하고 -> 이제는 해당 클래스에 선언되어있고 사용되고 있는 애노테이션들을 getAnnotation()을 사용해서 가져오고\
해당 애노테이션을 타입으로 가지는 객체를 생성해서 .fieldName()을 통해서 애노테이션 내부에 선언되어 있는 값들을 가지고 조작하는 것이 가능하다\
\
\


## 클래스 정보 수정

어떠한 객체를 생성하는 방식으로 생각해보면 일단 본인이 떠오르는 건 단순하게 new 키워드를 통해서 인스턴스를 생성하는 것밖에 아는 것이 없다\
하지만 그런 방식 이외에도 위에서 배운 리플렉션 api를 사용해서 객체를 생성하는 것도 가능하다\


```java
        Class<?> aClass = Class.forName("me.kyu9.java8to11.Progress");
        Constructor<?> constructor = aClass.getConstructor();
        Progress progress = (Progress) constructor.newInstance();
```

이렇게 생성자를 가져오고, 생성자의 newInstance 함수와 해당 클래스로의 형변환을 통해서 객체를 생성하는 것이 가능하다\
\


이렇게 객체를 가져온 이후에, 필드 이외에도 메소드를 가져오는 것 또한 가능하다\
그 방법으로는 getDeclaredMethod를 통해서 가져올 수 있으며 이 함수를 사용할때는 reference 타입과 primitive 타입을 구분한다\
가져온 메소드의 접근지정자를 만약에 private으로 정해져 있다면, .setAccessible()을 통해서 수정하는 것이 가능하며\
.invoke()을 통해서 해당 메소드의 내부 기능을 수행시키는 것이 가능하다 그리고 invoke()를 수행하게 되면, Object타입으로 리턴되기 때문에 형변환 해야한다\
\
\
\


## 정리

리플렉션은 뭔가 매우 강력하면서도 클래스 자체에 대한 api이기 때문에 무거운? 그러한 api라고 생각한다\
이 것들은 정말 많은 곳들에서 사용하고 있다. 스프링에서도 DI를 하는데 있어서 사용한다고 한다 또한 특정한 뷰에서 값이 넘어올 때 넝어온 값을 객체로 바인딩하는데도 사용\
하지만 이것의 문제는 컴파일 시점에서는 에러가 나오지는 않으며 런타임 시점에 에러가 나오는 문제를 만들 수도 있다는 점이 있다\
물론 위에서 무겁고 뭐 런타임시에만 발견되는 문제를 만들 수도 있다 이러한 문제점들은 충분한 이해가 없는 경우에 나타나기 때문에 사용할 때는 충분한 이해와 테스트를 거치고 사용하자\
그리고 또 문제가 있다면 setAccessible 통해서 접근 지시자를 무시하고 사용하는 것이 가능하기 때문에 캡슐화의 법칙을 위반하는 경우가 생길 수도 있다는 점\
이렇게 자바의 내부적인 값에 접근하고, 사용하는 것은 정말 좋은 지식이고 활용도 높으며 프레임워크를 이해하는데도 좋은 용도라고 생각한다\
실제로 사용할 때는 그래도 충분한 이해를 가지고 사용할 수 있도록 하자\
\
\


\
\
\
\
\
\
\
\
\
\
