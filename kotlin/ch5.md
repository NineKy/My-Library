# 람다로 프로그래밍
람다라는 의미는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 의미한다 <br>
<br>

람다는 약간 논리?를 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다 <br>
그래서 원래는 내부에서 익명클래스을 사용해서 코드를 함수에 넘기거나 변수에 담거나 이러한 과정을 거쳤었다 <br>
근데 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 사용해서 귀찮은 단계를 모두 해결해버렸다 <br>
클래스를 선언하고, 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다 
람다를 사용하면 간결하게 함수를 선언하지 않고, 코드블록을 함수의 인자로 전달하는 것이 가능하다 <br>
<br><br>

### 람다 식의 문법
람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 람다를 따로 선언해서 변수에 저장하는 것도 가능하긴 하지만 일단은
함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다 <br>
람다의 구조는 이러하다 => {x: Int, y: Int -> x+y} <br>
화살표를 기준으로 파라미터부분과 람다부분으로 나뉘게 된다 <br>
람다 식은 변수에 저장하는 것이 이런식으로 가능하다 <br>
```java
val sum = {x: Int, y: Int -> x+y}
println(sum)
```
이렇게 람다를 변수에 직접 집어넣어서 사용하는 것이 아주 효율적이긴 하다 자바에서는 식을 만들고 그 식을 적용한 변수에 넣어주고 
이렇게 2단계를 거쳐서 해야할 일을 이제는 단 한줄로 불필요한 단계들을 없앴다 <br>
그리고 람다를 만들고 바로 호출하는 것보다 람다 본문을 직접 실행하는 방법이 있다. 즉, 코드의 일부분을 블록으로 둘러싸서 실행할 필요가 있을 때는 run 이라는 키워드를 사용한다 <br>
run은 인자로 받은 람다를 실행해주는 라이브러리 함수이다 <br>
실행 시점에 코틀린 람다 호출에는 아무런 비용이들지 않는것도 특징이다 <br>
그래서 결과적으로 어떻게 사용하느냐, 방식은 간단하다 - 예를 들어서 콜렉션에서 최대값을 구하는 maxBy 라는 함수로 봐보자 <br>
람다로 어떤 값을 인자로 넘기는 케이스 <br>
people.maxBy({p: Person -> p.age}) <br>
만약 어떤 함수의 파라미터가 하나인 경우에는 이렇게 중괄호를 빼서 사용한 케이스 <br>
people.maxBy() {p: Person -> p.age} <br>
아니면 그냥 괄호는 없애도 가능한 케이스 <br>
people.maxBy {p: Person -> p.age} <br>
사실 여기서 굳이 파라미터를 선언적으로 명시해줄 필요는 없다 <br>
people.maxBy {p -> p.age} <br>
요렇게 파라미터의 타입을 생략해서 컴파일러가 알아서 추론하도록 하는 것도 가능하다 -> 뭐 당연하게 추론가능한 경우에는 이렇게 할 수 있다는 점은 상식적으로 이해할 수 있다 <br>
그리고 파라미터 중 일부의 타입은 저장하고 나머지 파라미터 타입을 지정하지 않고 이름만 남겨두는 것도 가능하다 <br>
파라미터 중 일부의 타입은 지정하고 나머지는 알아서 하도록 이름만 선언한 것도 가능하다는 점 <br>
<br>
그리고 람다의 파라미터 이름을 람다의 디폴트 이름인 it로 바꿔서 더욱 간단하게 할 수 있는데 요놈의 조건은 이하와 같다 
우선 람다의 파라미터가 하나뿐이고, 그 타입을 컴파일러가 추론할 수 있는 경우에는 바로 it를 사용할 수 있다 <br>
사용방법은 이렇다 people.maxBy {it.age} <br>
여기서 it란 자동으로 생성한 파라미터의 이름이다 근데 정말 간단하게 처리해주지만 값이 중첩되고 그러면 it가 어떤 파라미터를 의미하는지에 대한 애매모호함이 생길 수 있다고 생각하기 때문에 조심해야한다 <br>
<br><br>

자바에서 무명 클래스를 사용할때 메소드의 로컬변수를 내부 클래스 안에서 사용할 수 있었다. 람다에서도 같은 방식이 가능하다 즉, 
람다를 함수 안에서 정의하면, 함수의 파라미터 뿐만아니라 람다 정의 앞에 선언된 로컬변수까지 람다에서 사용하는 것이 가능하다 <br>
자바에서는 람다내부에서만 있는 변수만 사용가능했었지만 코틀린에서는 람다 밖에서 선언한 바깥 변수를 변경하거나 접근하는 것이 가능하다 <br>
반대로 람다 내부에서 선언하고 사용한 변수는 기본적으로 변수의 생명주기가 함수가 종료될 때이다 근데 만약 내부에 있는 함수를 밖에서도 사용하고 싶다면
변수를 포획함을 통해서 변수의 생명주기를 변경하는 것이 가능하다 기본적으로 파이널인 변수를 포획한 경우에는 람다 코드를 변수 값과 함꼐 저장한다 
파이널이 아닌 경우에는 변수를 특별한 래퍼로 감싸서 래퍼를 통해서 사용한다 <br>
<br><br>

멤버를 참조하는 방법은 자바에서의 메소드 레퍼런스와 같은 방식인 :: 을 통해서 참조한다 <br>
::을 사용하는 식을 멤버 참조라고 부르는데, 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다 <br>
val myAge = Person::age <br>
요렇게 생긴 것인데 val myAge = {p: Person -> p.age} 이 람다 방식을 줄이는 방식이라고 볼 수 있다 <br>
추가로 굳이 클래스::멤버 이렇게 참조하지 않고 클래스 이름을 생략하고 ::으로 참조를 바로 시작하는 것도 가능하다 <br>
람다가 인자가 다양한 다른 함수에게 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임함수에 대한 참조를 제공하면 편리하다 <br>
```java
//이 람다를 통해서 sendEmail 함수에게 작업을 위임
val action = { p: Person, msg: String -> sendEmail(p, msg)}
//람다 대신 멤버 참조를 사용할 수 있다
val nextAction = ::sendEmail
```
또한 생성자 참조에서 이렇게 ::을 사용해서 진행하는데, 이렇게 사용하면 클래스 생성 작업을 연기하거나 저장하는 것이 가능하다 <br>
<br><br><br>





<br><br><br><br><br><br><br><br><br><br>