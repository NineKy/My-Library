# 고차 함수 : 파라미터와 리턴 값으로 람다 사용 
어떻게 보면 메소드 체이닝과 같이 코드의 중복을 없애고 변수를 만들고 그 변수로 로직이 돌아가는 그런느낌이 아니니라 함수에서 변수가 생기면 그 변수를 바로바로 람다를 통해서 작업할 수 있다 
고차함수란 다른 함수를 인자로 받거나 함수를 반환해주는 함수이다 -> 함수 참조를 사용해서 함수를 값으로 표현할 수 있다 <br>
그래서 고차함수는 람다나 함수 참조를 인자로 넘길 수 있거나 람다나 함수 참조를 반환하는 함수이고 함수를 인자를 받는 동시에 함수를 반환하는 것도 가능하다 <br>
<br><br>

### 고차 함수 정의
코틀린에서는 타입 추론을 통해서 변수 타입을 지정하지 않아도 람다를 변수에 대입할 수 있다 <br>
```kotlin
//기본적으로 배우고 사용하던 방법 -> 자동으로 타입을 인지해서 리턴 타입을 선언하지 않아도 잘 적용되었음
val sum = {x: Int, y: Int -> x+y}
val action = { println("fun")}
    
//물론 직접 명시하는 것을 통해서 어떤 타입을 사용할지에 대한 정의도 가능
val sum2: (Int, Int) -> Int = {x, y -> x+y}
val action2: () -> Unit = { println("fun")}
```
이렇게 파라미터로 들어가는 타입을 괄호 안에 넣어주고, 그 뒤에 화살표를 통해서 리턴 타입을 명시해준다 익명함수처럼 리턴값이 따로 존재하지 않는 케이스에서는 자바에서의 void와 같은 의미인 
Unit을 통해서 명시해줄 수 있다 없다고해서 명시를 안해주면 안된다 <br>
추가로 nullable 타입을 리턴하는 것도 가능한데 ((Int, Int)->Int)? = null 이렇게 널러블 타입을 리턴하는이 가능하다는 점이다 <br>
<br><br>

그래서 고차함수를 어떻게 선언하냐 <br>
```kotlin
    fun twoAndThree(operation: (Int, Int) -> Int){
        val result = operation(2, 3)
        println("$result is RESULT")
    }

    twoAndThree{ a, b -> a+b} //5
    twoAndThree{ a, b -> a*b} //6
    
```
이 함수는 2,3에 대해서 인자로 받은 연산을 수행하고 결과를 내보낸다 이렇게 인자로 받은 함수를 호출하는 구분은 일반 함수를 호출하는 것과 동일하다 <br>
심지어 자바에서도 코틀린 함수 타입을 사용할 수 있다 어짜피 컴파일된 코드 안에서 함수 타입은 일반 인터페이스로 변경되기 때문에 함수 타입의 변수는 FunctionN 인터페이스를 구현하는 객체를 저장 한다 <br>
코틀린 표준 라이브러리 함수는 인자의 갯수에 따라 Function0<R> (인자가 없는 함수), Function1<P1, R> (인자가 하나 있는 함수) 이렇게 여러개 인터페이스를 제공하고 이러한 인터페이스
내부에는 invoke 메소드가 있고 이걸 통해서 함수를 실행한다 그래서 함수 타입인 변수는 인자 갯수에 따라 적당한 FunctionN 인터페이스를 구현하는 클래스의 인스턴스를 저장하고 invoke 메소드에 람다의 본문이 들어가는 방식이다 <br>
위에서 코틀린에서 사용한 것 처럼 사용하되, Unit 대신 void 으로 수정이 되어야함 <br>
<br><br>

함수에서 함수를 반환하는 경우도 있다 <br>
이런건 이제 상태나 조건에 따라서 로직이 달라지는 경우에 사용할 수 있다 <br>
책에서 예시로 들어준 부분은 자신이 선택한 배송 수단에 따라서 배송비를 계산하는 로직이 다른 케이스를 적절한 로직을 선택해서 함수로 반환하는 함수를 만드는 것을 보여주었다 <br>
```kotlin
package me.kyu9.ktexercise.ch7

class Order(val itemCount: Int) {}

fun getShippingCalculator(type: String): (Order) -> Double { // 함수를 리턴하는 함수를 선언
    
    //함수에서 람다를 리턴
    if(type == "DELIVERY"){
        return { order -> 2.0 * order.itemCount }
    }else{
        return { order -> 1.5 * order.itemCount }
    }
}

fun main() {
    //리턴받은 함수를 변수에 저장하는데 어떠한 타입의 로직인지를 명시해서 해당 변수에 저장을 해둠
    val calculator = getShippingCalculator("EXPIRE")
    //리턴받은 함수를 호출해서 해당 객체가 무엇이냐에 따라서 금액 계산 
    println("calculated : ${calculator(Order(20))}")

}

```
이렇게 다른 함수를 리턴하는 함수를 정의하기 위해서는 함수의 리턴 타입으로 함수 타입을 지정해주어야 한다 <br>
<br><br>

함수타입과 람다식은 중복 제거에 스페셜리스트이다 람다를 사용하니까 복잡한 구조의 코드도 간결하게 사용될 수 있다 그리고 코틀린스럽게 만드는 것이 람다를 적극 활용한다는 의미이다 <br>
중복을 없앤다는 것은 즉 중복되는 코드를 람다로 만드는 방식으로 없앤다는 의미이다... 일단 많은 예시를 눈으로 익히고 봐보자 <br>
<br><br>

































