# Elastic Search

## Elastic Search 란?
Lucene 이라는 검색 기능을 제공해주는 자바 라이브러리를 기반으로 만든 오픈 소스 검색 엔진입니다 <br>
JSON 기반의 문서를 저장하고 검색하는 것이 가능하며 해당 데이터들을 분석하는 작업 또한 가능합니다 <br>
<br>

중요한 특징으로는 아래와 같은 내용이 있습니다
- realtime 검색 시스템
  - Elasticsearch 클러스터가 돌고 있는 동안 검색과 데이터의 적재가 거의 동시에 일어나고 있기 때문에 엄청나게 빠른 속도를 자랑합니다 - 속도 지정하는 것도 가능
- 클러스터 구조
  - 하나 이상의 노드로 구성해서 데이터 관리, 검색에서 높은 수준의 안정성을 보여줄 수 있으며 부하의 분산도 가능합니다 
- Rest API 기반의 인터페이스
  - 단순하게 Elasticsearch 서버에 api 을 쏘는 방식으로 elasticsearch 을 시용하는 것이 가능합니다
- 동적 스키마 생성
  - RDBMS 와 비교해서 생각해보면, 스키마를 생성하고 데이터를 적재하는 방식이 아니라 동적으로 생성하기 떄문에 따로 미리 정의할 필요가 없습니다

<br><br>

## Elastic Search 의 기본 개념

### ES의 시스템 구조
간단한 도식화
![img_1.png](img_1.png)
위의 도식화는 **클러스터링 구조**를 가지고 있으면서 클러스터 내부에서는 **여러개의 노드**로 나뉘어져있으며, <br>
각각의 노드 안에는 **인덱스**들이 구성되어 있습니다 <br><br><br>



#### 클러스터
위키백과에서는 '컴퓨터 클러스터는 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말한다' <br>
ES을 가장 밖에서 봤을 떄의 구조라고 볼 수 있습니다 <br>
<br><br>

##### 노드
클러스터 내부에 구성되어 있는 각각의 기능을 가진 하나의 단위라고 정의해보았습니다 <br>
각각의 노드는 가장 많이 사용하는 종류로 나누어보면 4개의 종류로 나뉠 수 있습니다 <br>
- 마스터 노드 : 클러스터 상태 관리 및 메타 데이터 관리
  - 마스터 노드가 있어도 마스터 노드가 뻗는 경우에 다음 마스터 노드를 설정할 수 있도록 **후보 마스터 노드**를 가질 것인지에 대한 여부를 설정할 수 있습니다
- 데이터 노드 : 문서 색인 및 검색 요청 처리
  - 해당 노드에 데이터를 저장할 것인지 지정하는 것이 가능합니다
- 코디네이팅 노드 : 검색 요청 처리
- 인제스트 노드 : 색인되는 문서의 데이터 전처리

<br>

클러스터 구조를 가져가고 있는 ES이기 떄문에 가지는 특징들도 있습니다. <br>
우선은 위에서 정의한 4가지의 노드들은 뭐 각각의 특징을 가지고 있다고는 했지만 사실 각각의 모든 노드들은 위에서 정의한 모든 역할을 수행하는 것이 가능합니다 <br>
그렇기 때문에 기본적으로는 >> 어떤 노드에게 요청을 하던지 모든 노드는 **동일한 결과**를 돌려줄 것이라는 것입니다 <br>
<br>

위에서 많이 쓰인다고 언급한 각각의 특성들은 config 에서 true/false 값의 조정을 통해서 설정하는 것이 가능한데 <br>
해당 작업을 통해서 각 노드에서 모든 기능을 수행하는 것이 아닌 MSA 와 같이 각각의 독립적인 기능을 한 노드를 구성하는 것이 가능합니다 <br>
해당 작업의 의의는 노드밸런싱을 통해서 각 노드별로 부하가 가지 않도록 처리하고 각 노드에 맞게 라우팅해주는 작업이 필요합니다 <br>
<br><br>


#### 인덱스와 샤드
요기 부분은 실제로 데이터가 들어가는 부분에 대한 내용이기 때문에 RDBMS와 비교한 용어를 보면 편할 것 같아서 정리해봤습니다
<table>
  <tr>
    <th>RDBMS</th>
    <th>ES</th>
  </tr>
  <tr>
    <td>database</td>
    <td>index</td>
  </tr>
  <tr>
    <td>schema</td>
    <td>mapping</td>
  </tr>
    <tr>
    <td>row</td>
    <td>document</td>
  </tr>
</table>

<br>

위의 표를 정리해보면 ES 에서는 RDBMS에서 저장되는 데이터를 보고 document 이라고 명명하고 있으며 <br>
document를 모아둔 집합을 보고 인덱스라고 명명하고 있습니다<br>

**인덱스란** <br>
document가 저장되는 논리적인 공간이고 인덱스가 구성이 되어있어야만 document을 저장하는 것이 가능합니다 <br>
인덱스를 설계하는 것이 ES을 사용하는데 가장 고려가 필요한 부분이라고 합니다 <br>

<br>
예시) <br>
book, magazine, dvd 이러한 개념들이 있다고 가정해봅시다 <br>
이들을 각각의 index으로 저장할 것인지 vs library 이라는 공통된 index 으로 저장할 것인지 <br>
나눈다면 > 관리 리소스가 요하지만 쿼리나 문서구조가 간단 <br>
통합한다면 > 관리적인 관점에서는 편리하지만, 쿼리나 문서구조를 포기 <br>
강의에서는 우선 저장하고자 하는 애의 통합적인 것으로 구조를 잡아두고 쪼개는 방식을 추천합니다 <br>
<br>


**샤드란** <br>
인덱스에 색인되는 문서가 저장되는 공간이고 하나의 인덱스는 반드시 하나 이상의 샤드를 갖습니다 <br>
따라서 인덱스(1)는 (n)개의 샤드로 분리되어 각 노드에 분산되어 저장되게 됩니다 <br> 
+샤드는 ES의 기반인 루씬(Lucene)의 단일 검색 인스턴스라고 하네요
<br><br>

샤드의 구조는 프라이머리 / 레플리카 이렇게 크게 나뉘어집니다 <br>
프라이머리는 문서가 저장되는 원본 샤드이고, 해당 샤드는 색인과 검색 성능 모두에게 큰 영향을 줍니다 <br>
레플리카는 프라이머리의 복제 샤드이고, 복제된 샤드이기 때문에 검색 성능에 영향을 끼지는 샤드이고 만약 프라이머리에 문제가 생긴다면 프라이머리가 될 수도 있습니다 <br>
<br>

레플리카가 만들어지게 되면 프라이머리와 동일한 노드에 구성되는 것이 아닌 반드시 다른 노드에 구성되어 있습니다 <br>
그래야 위에서 언급한 내용인 프라이머리에 문제가 생기면 프라이머리로 승격하는 것이 가능합니다(승격하면서 새로운 레플리카를 생성합니다) <br>
추가로 ES에서는 아무리 작은 클러스터 구조여도 최소 3개의 노드를 구성할 것을 권장하고 있습니다 <br>
<br>

샤드의 갯수 설정은 인덱스를 생성하는 시점에 지정합니다 <br>
인덱스를 생성할 떄 > settings 항목에 number_of_shards, number_of_replicas 두 항목을 통해서 설정할 수 있습니다 <br>
인덱스 생성 시, 샤드의 갯수를 지정하는 과정에서 가장 중요한 항목은 > 프라이머리 샤드의 갯수는 인덱스를 처음 생성하는 시점에만 지정할 수 있다는 것입니다 <br>
기본 값으로는 number_of_shards 가 1인데, 1 그대로 사용하게 되면 성능 상 문제가 될 수 있으니 예시 및 실습이 좀 필요할 듯합니다 <br>
+일일이 인덱스 생성할 때마다 이것을 조절하는 것은 어려울 것으로 보이니 인덱스 템플릿으로 공통화해서 작업하는 것도 가능하니 참고 <br>
number_of_shards 는 프라이머리 샤드의 갯수 <br>
number_of_replicas 는 복제 샤드의 갯수 <br>
그럼 복제 샤드는 프라이머리 샤드 하나 당 나오는 구조이기 때문에 총 샤드의 갯수는 number_of_shards * number_of_replicas 로 볼 수 있습니다 <br>
<br><br>

결과적으로 지금까지 확인한 사항을 보고 위에 raw하게 그린 항목에 내용을 집어넣어 ES의 총괄적 구조를 보면 <br>
이렇게 볼 수 있습니다 <br>
![img.png](img.png)
<br>

<br><br>

